# 信道分配协议

## 争用协议（Aloha）

ALOHA 协议是最简单的一个基本协议：无论何时，只要用户有需要就发送数据，当发送冲突导致帧损坏时，发送方等待一段**随机**时间，然后再次发送该帧。该协议期望的最好的信道利用率为 $1 / 2e$。

为了改善信道利用率，又提出一种**分槽** ALOHA 协议，将时间分成**离散的时间槽**。在分槽 ALOHA 中，无论何时，用户需要**等到某一个时间槽的开始时刻**才能发送数据，这使得信道利用率提升到了 $1 / e$。

## 载波侦听多路访问协议

如果在一个协议中，站监听是否存在**载波**（即是否有传输），并据此采取相应的动作，则这样的协议被称为**载波侦听协议**。

### 1-坚持型载波检测多路访问

1-坚持型载波检测多路访问是最简单的 CSMA 方案。当一个站有数据要发送时，它首先**侦听信道**，确定当时是否有其他站正在传输数据：如果信道空闲，它就发送数据；如果信道被忙，该站就等待，直到信道变成空闲，然后该站**立即**发送该帧；如果发生冲突，该站等待一段随机长度的时间，然后从头开始上述过程。

### 非坚持型载波检测多路访问

考虑这样一个场景：两个站都在第三个站发送数据时监听到了信道忙，然后准备好了要发送的数据进行等待。采用 1-坚持型载波检测多路访问，两个站在第三个站结束传输的同时开始发送数据，这显然会导致发生冲突。

于是在非坚持型载波检测多路访问协议中，如果发送站检测到信道忙，它不会持续对信道进行监听，而是**等待一段随机时间**再重复算法。该算法会有更好的信道利用率，但是延迟更大。

### $p$-坚持型载波检测多路访问

最后一种协议结合了上面两种的协议。当一个站准备好要发送数据时，它开始侦听信道：如果信道空闲，则它按**照概率 $p$ 发送数据**，以 $q = 1 - p$ 的概率将此次发送**推迟到下一个时间槽**；如果信道忙，则它等到下一个时间槽，然后重复算法。

### 带冲突检测的 CSMA

坚持型和非坚持型 CSMA 协议都是对 ALOHA 的改进，然而如果两个站同时开始传输，则它们的信号还是会发生冲突。因此另一个改进是这些站尽快检测到发生冲突后立即停止传输帧（而不是继续完成传输），因为这些帧已经被损坏。

!!! note "冲突检测"
    站的硬件在传输时必须侦听信道，**如果它读会的信号不同于它放到信道上的信号**，则它就知道发生了冲突。

在带冲突检测的 CSMA（CSMA/CD）协议中，如果一个站检测到冲突，它立即终止自己的传输，并**等待一段随机时间**，然后再重新尝试传输。

!!! question "假定两个站同时在 $t_0$ 时刻开始传输数据，他们需要多长时间才能意识到发生了冲突？"

    考虑**最坏的情形**，假设两个相距最远的站传播信号需要的时间为 $\tau$。在 $t_0$ 时刻，一个站开始传输数据，在 $t = t_0 + \tau - \varepsilon$ 时刻即到达**前一刹那**，那个站也开始传输。后者立即就检测到了冲突，而前者则需要再等待 $\tau$ 时间才能检测到冲突。也就是说总共要 $2\tau - \varepsilon$ 时间。

## 无线局域网协议

无线局域网（WLAN）最基本使用 CSMA 协议，但由于各个站点发出的信号范围有限（不像有线网络中一个站点发出的信号可到达所有的站点），因此会造成**隐藏站点**问题和**暴露站点**问题。

=== "隐藏站点问题"

    ```mermaid
    graph LR;
        A(站点 A) <-.-> B(站点 B)
        B <-.-> C(站点 C)
        C <-.-> D(站点 D)

        A ---> |发送信息| B
        C ---> |发送信息| B
    ```

    在隐藏站点问题中，站点 A 和站点 C 无法直接检测到彼此的信号，因此可能会同时尝试与站点 B 通信，导致冲突。

=== "暴露站点问题"

    ```mermaid
    graph LR;
        A(站点 A) <-.-> B(站点 B)
        B <-.-> C(站点 C)
        C <-.-> D(站点 D)

        B ---> |发送信息| A
        C ---> |监听信道| B
    ```

    在暴露站点问题中，站点 B 和站点 C 可以检测到彼此的信号，因此当站点 B 向 A 发送信息时，C 可能误以为信道忙而不向 B 发送信息。

### 带冲突避免的 CSMA

在带冲突避免的 CSMA（CSMA/CA）中，发送方先发送一个请求发送（RTS）帧，接收方收到后回复一个清除发送（CTS）帧，这样接收方周围的站点就知道在即将到来的数据帧期间不要发送数据，从而避免冲突。

当多个站点同时向一个站点发送 RTS 帧时仍可能发生冲突。如果在预定时间内没有收到 CTS 帧，发送方将采用**二进制指数退避算法**，等待一段随机时间后再次重试。

!!! note annotate "二进制指数退避算法"
    当两个站第 $i$ 次发生冲突时，在 $0 \sim 2^i - 1$ 范围内随机选择等待的时间槽数。(1)

1.  第一次发生冲突时，两个发送站分别随机等待 0 个或 1 个时间槽。若两个站选择了同样的数字，则发生第二次冲突，两个站分别选择 0，1，2 或 3 个时间槽等待，以此类推。
